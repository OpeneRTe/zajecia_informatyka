# Promise w JavaScript – resolve i reject

## Podstawy
Obiekt `Promise` reprezentuje operację asynchroniczną, która może zakończyć się:
- **sukcesem** (fulfilled),
- **błędem** (rejected).

Tworzymy go za pomocą konstruktora:

```js
const p = new Promise((resolve, reject) => {
  // kod asynchroniczny tutaj
});
```

Funkcja przekazana do konstruktora nazywa się **executor**. Automatycznie dostaje ona dwie funkcje:
- `resolve(value)` – zakończ sukcesem i przekaż `value`,
- `reject(error)` – zakończ błędem i przekaż `error`.

## Wariant 1 – sukces (resolve)
```js
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve("Hello Promise");
  }, 2000);
});

p.then(
  wynik => console.log("OK:", wynik),
  error => console.log("Błąd:", error.message)
);
```

### Przebieg
1. Tworzony jest `Promise` w stanie **pending**.
2. Po 2 sekundach wywołuje się `resolve("Hello Promise")`.
3. Stan zmienia się na **fulfilled**.
4. `.then(...)` wywołuje **pierwszy callback** (onFulfilled).
5. Wynik w konsoli:
```
OK: Hello Promise
```

---

## Wariant 2 – błąd (reject)
```js
const p = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error("asd"));
  }, 2000);
});

p.then(
  wynik => console.log("OK:", wynik),
  error => console.log("Błąd:", error.message)
);
```

### Przebieg
1. Tworzony jest `Promise` w stanie **pending**.
2. Po 2 sekundach wywołuje się `reject(new Error("asd"))`.
3. Stan zmienia się na **rejected**.
4. `.then(...)` wywołuje **drugi callback** (onRejected).
5. Wynik w konsoli:
```
Błąd: asd
```

---

## Diagram stanu Promise

```
Nowy Promise
   |
   V
Stan: pending
   |
   |-- resolve(value) --> Stan: fulfilled --> uruchamia .then(onFulfilled)
   |
   |-- reject(error)  --> Stan: rejected  --> uruchamia .then(onRejected)
```

---

## Podsumowanie
- `resolve` i `reject` są funkcjami przekazanymi automatycznie przez silnik JS.
- Wywołanie `resolve(...)` przełącza Promise w stan **fulfilled**.
- Wywołanie `reject(...)` przełącza Promise w stan **rejected**.
- `.then()` przyjmuje dwa callbacki: pierwszy dla sukcesu, drugi dla błędu.
